// Copyright 2018-2022 CERN
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// In applying this license, CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

// Code generated by mockery v2.14.1. DO NOT EDIT.

package mocks

import (
	context "context"

	acl "github.com/cs3org/reva/v2/pkg/storage/utils/acl"

	eosclient "github.com/cs3org/reva/v2/pkg/eosclient"

	io "io"

	mock "github.com/stretchr/testify/mock"
)

// EOSClient is an autogenerated mock type for the EOSClient type
type EOSClient struct {
	mock.Mock
}

// AddACL provides a mock function with given fields: ctx, auth, rootAuth, path, position, a
func (_m *EOSClient) AddACL(ctx context.Context, auth eosclient.Authorization, rootAuth eosclient.Authorization, path string, position uint, a *acl.Entry) error {
	ret := _m.Called(ctx, auth, rootAuth, path, position, a)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, eosclient.Authorization, eosclient.Authorization, string, uint, *acl.Entry) error); ok {
		r0 = rf(ctx, auth, rootAuth, path, position, a)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Chmod provides a mock function with given fields: ctx, auth, mode, path
func (_m *EOSClient) Chmod(ctx context.Context, auth eosclient.Authorization, mode string, path string) error {
	ret := _m.Called(ctx, auth, mode, path)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, eosclient.Authorization, string, string) error); ok {
		r0 = rf(ctx, auth, mode, path)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Chown provides a mock function with given fields: ctx, auth, chownauth, path
func (_m *EOSClient) Chown(ctx context.Context, auth eosclient.Authorization, chownauth eosclient.Authorization, path string) error {
	ret := _m.Called(ctx, auth, chownauth, path)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, eosclient.Authorization, eosclient.Authorization, string) error); ok {
		r0 = rf(ctx, auth, chownauth, path)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateDir provides a mock function with given fields: ctx, auth, path
func (_m *EOSClient) CreateDir(ctx context.Context, auth eosclient.Authorization, path string) error {
	ret := _m.Called(ctx, auth, path)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, eosclient.Authorization, string) error); ok {
		r0 = rf(ctx, auth, path)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GenerateToken provides a mock function with given fields: ctx, auth, path, a
func (_m *EOSClient) GenerateToken(ctx context.Context, auth eosclient.Authorization, path string, a *acl.Entry) (string, error) {
	ret := _m.Called(ctx, auth, path, a)

	var r0 string
	if rf, ok := ret.Get(0).(func(context.Context, eosclient.Authorization, string, *acl.Entry) string); ok {
		r0 = rf(ctx, auth, path, a)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, eosclient.Authorization, string, *acl.Entry) error); ok {
		r1 = rf(ctx, auth, path, a)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetACL provides a mock function with given fields: ctx, auth, path, aclType, target
func (_m *EOSClient) GetACL(ctx context.Context, auth eosclient.Authorization, path string, aclType string, target string) (*acl.Entry, error) {
	ret := _m.Called(ctx, auth, path, aclType, target)

	var r0 *acl.Entry
	if rf, ok := ret.Get(0).(func(context.Context, eosclient.Authorization, string, string, string) *acl.Entry); ok {
		r0 = rf(ctx, auth, path, aclType, target)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*acl.Entry)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, eosclient.Authorization, string, string, string) error); ok {
		r1 = rf(ctx, auth, path, aclType, target)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAttr provides a mock function with given fields: ctx, auth, key, path
func (_m *EOSClient) GetAttr(ctx context.Context, auth eosclient.Authorization, key string, path string) (*eosclient.Attribute, error) {
	ret := _m.Called(ctx, auth, key, path)

	var r0 *eosclient.Attribute
	if rf, ok := ret.Get(0).(func(context.Context, eosclient.Authorization, string, string) *eosclient.Attribute); ok {
		r0 = rf(ctx, auth, key, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eosclient.Attribute)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, eosclient.Authorization, string, string) error); ok {
		r1 = rf(ctx, auth, key, path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFileInfoByFXID provides a mock function with given fields: ctx, auth, fxid
func (_m *EOSClient) GetFileInfoByFXID(ctx context.Context, auth eosclient.Authorization, fxid string) (*eosclient.FileInfo, error) {
	ret := _m.Called(ctx, auth, fxid)

	var r0 *eosclient.FileInfo
	if rf, ok := ret.Get(0).(func(context.Context, eosclient.Authorization, string) *eosclient.FileInfo); ok {
		r0 = rf(ctx, auth, fxid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eosclient.FileInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, eosclient.Authorization, string) error); ok {
		r1 = rf(ctx, auth, fxid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFileInfoByInode provides a mock function with given fields: ctx, auth, inode
func (_m *EOSClient) GetFileInfoByInode(ctx context.Context, auth eosclient.Authorization, inode uint64) (*eosclient.FileInfo, error) {
	ret := _m.Called(ctx, auth, inode)

	var r0 *eosclient.FileInfo
	if rf, ok := ret.Get(0).(func(context.Context, eosclient.Authorization, uint64) *eosclient.FileInfo); ok {
		r0 = rf(ctx, auth, inode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eosclient.FileInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, eosclient.Authorization, uint64) error); ok {
		r1 = rf(ctx, auth, inode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFileInfoByPath provides a mock function with given fields: ctx, auth, path
func (_m *EOSClient) GetFileInfoByPath(ctx context.Context, auth eosclient.Authorization, path string) (*eosclient.FileInfo, error) {
	ret := _m.Called(ctx, auth, path)

	var r0 *eosclient.FileInfo
	if rf, ok := ret.Get(0).(func(context.Context, eosclient.Authorization, string) *eosclient.FileInfo); ok {
		r0 = rf(ctx, auth, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eosclient.FileInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, eosclient.Authorization, string) error); ok {
		r1 = rf(ctx, auth, path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetQuota provides a mock function with given fields: ctx, username, rootAuth, path
func (_m *EOSClient) GetQuota(ctx context.Context, username string, rootAuth eosclient.Authorization, path string) (*eosclient.QuotaInfo, error) {
	ret := _m.Called(ctx, username, rootAuth, path)

	var r0 *eosclient.QuotaInfo
	if rf, ok := ret.Get(0).(func(context.Context, string, eosclient.Authorization, string) *eosclient.QuotaInfo); ok {
		r0 = rf(ctx, username, rootAuth, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eosclient.QuotaInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, eosclient.Authorization, string) error); ok {
		r1 = rf(ctx, username, rootAuth, path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// List provides a mock function with given fields: ctx, auth, path
func (_m *EOSClient) List(ctx context.Context, auth eosclient.Authorization, path string) ([]*eosclient.FileInfo, error) {
	ret := _m.Called(ctx, auth, path)

	var r0 []*eosclient.FileInfo
	if rf, ok := ret.Get(0).(func(context.Context, eosclient.Authorization, string) []*eosclient.FileInfo); ok {
		r0 = rf(ctx, auth, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*eosclient.FileInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, eosclient.Authorization, string) error); ok {
		r1 = rf(ctx, auth, path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListACLs provides a mock function with given fields: ctx, auth, path
func (_m *EOSClient) ListACLs(ctx context.Context, auth eosclient.Authorization, path string) ([]*acl.Entry, error) {
	ret := _m.Called(ctx, auth, path)

	var r0 []*acl.Entry
	if rf, ok := ret.Get(0).(func(context.Context, eosclient.Authorization, string) []*acl.Entry); ok {
		r0 = rf(ctx, auth, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*acl.Entry)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, eosclient.Authorization, string) error); ok {
		r1 = rf(ctx, auth, path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDeletedEntries provides a mock function with given fields: ctx, auth
func (_m *EOSClient) ListDeletedEntries(ctx context.Context, auth eosclient.Authorization) ([]*eosclient.DeletedEntry, error) {
	ret := _m.Called(ctx, auth)

	var r0 []*eosclient.DeletedEntry
	if rf, ok := ret.Get(0).(func(context.Context, eosclient.Authorization) []*eosclient.DeletedEntry); ok {
		r0 = rf(ctx, auth)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*eosclient.DeletedEntry)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, eosclient.Authorization) error); ok {
		r1 = rf(ctx, auth)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListVersions provides a mock function with given fields: ctx, auth, p
func (_m *EOSClient) ListVersions(ctx context.Context, auth eosclient.Authorization, p string) ([]*eosclient.FileInfo, error) {
	ret := _m.Called(ctx, auth, p)

	var r0 []*eosclient.FileInfo
	if rf, ok := ret.Get(0).(func(context.Context, eosclient.Authorization, string) []*eosclient.FileInfo); ok {
		r0 = rf(ctx, auth, p)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*eosclient.FileInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, eosclient.Authorization, string) error); ok {
		r1 = rf(ctx, auth, p)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PurgeDeletedEntries provides a mock function with given fields: ctx, auth
func (_m *EOSClient) PurgeDeletedEntries(ctx context.Context, auth eosclient.Authorization) error {
	ret := _m.Called(ctx, auth)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, eosclient.Authorization) error); ok {
		r0 = rf(ctx, auth)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Read provides a mock function with given fields: ctx, auth, path
func (_m *EOSClient) Read(ctx context.Context, auth eosclient.Authorization, path string) (io.ReadCloser, error) {
	ret := _m.Called(ctx, auth, path)

	var r0 io.ReadCloser
	if rf, ok := ret.Get(0).(func(context.Context, eosclient.Authorization, string) io.ReadCloser); ok {
		r0 = rf(ctx, auth, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.ReadCloser)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, eosclient.Authorization, string) error); ok {
		r1 = rf(ctx, auth, path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReadVersion provides a mock function with given fields: ctx, auth, p, version
func (_m *EOSClient) ReadVersion(ctx context.Context, auth eosclient.Authorization, p string, version string) (io.ReadCloser, error) {
	ret := _m.Called(ctx, auth, p, version)

	var r0 io.ReadCloser
	if rf, ok := ret.Get(0).(func(context.Context, eosclient.Authorization, string, string) io.ReadCloser); ok {
		r0 = rf(ctx, auth, p, version)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.ReadCloser)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, eosclient.Authorization, string, string) error); ok {
		r1 = rf(ctx, auth, p, version)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Remove provides a mock function with given fields: ctx, auth, path, noRecycle
func (_m *EOSClient) Remove(ctx context.Context, auth eosclient.Authorization, path string, noRecycle bool) error {
	ret := _m.Called(ctx, auth, path, noRecycle)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, eosclient.Authorization, string, bool) error); ok {
		r0 = rf(ctx, auth, path, noRecycle)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RemoveACL provides a mock function with given fields: ctx, auth, rootAuth, path, a
func (_m *EOSClient) RemoveACL(ctx context.Context, auth eosclient.Authorization, rootAuth eosclient.Authorization, path string, a *acl.Entry) error {
	ret := _m.Called(ctx, auth, rootAuth, path, a)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, eosclient.Authorization, eosclient.Authorization, string, *acl.Entry) error); ok {
		r0 = rf(ctx, auth, rootAuth, path, a)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Rename provides a mock function with given fields: ctx, auth, oldPath, newPath
func (_m *EOSClient) Rename(ctx context.Context, auth eosclient.Authorization, oldPath string, newPath string) error {
	ret := _m.Called(ctx, auth, oldPath, newPath)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, eosclient.Authorization, string, string) error); ok {
		r0 = rf(ctx, auth, oldPath, newPath)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RestoreDeletedEntry provides a mock function with given fields: ctx, auth, key
func (_m *EOSClient) RestoreDeletedEntry(ctx context.Context, auth eosclient.Authorization, key string) error {
	ret := _m.Called(ctx, auth, key)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, eosclient.Authorization, string) error); ok {
		r0 = rf(ctx, auth, key)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RollbackToVersion provides a mock function with given fields: ctx, auth, path, version
func (_m *EOSClient) RollbackToVersion(ctx context.Context, auth eosclient.Authorization, path string, version string) error {
	ret := _m.Called(ctx, auth, path, version)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, eosclient.Authorization, string, string) error); ok {
		r0 = rf(ctx, auth, path, version)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetAttr provides a mock function with given fields: ctx, auth, attr, errorIfExists, recursive, path
func (_m *EOSClient) SetAttr(ctx context.Context, auth eosclient.Authorization, attr *eosclient.Attribute, errorIfExists bool, recursive bool, path string) error {
	ret := _m.Called(ctx, auth, attr, errorIfExists, recursive, path)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, eosclient.Authorization, *eosclient.Attribute, bool, bool, string) error); ok {
		r0 = rf(ctx, auth, attr, errorIfExists, recursive, path)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetQuota provides a mock function with given fields: ctx, rooAuth, info
func (_m *EOSClient) SetQuota(ctx context.Context, rooAuth eosclient.Authorization, info *eosclient.SetQuotaInfo) error {
	ret := _m.Called(ctx, rooAuth, info)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, eosclient.Authorization, *eosclient.SetQuotaInfo) error); ok {
		r0 = rf(ctx, rooAuth, info)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Touch provides a mock function with given fields: ctx, auth, path
func (_m *EOSClient) Touch(ctx context.Context, auth eosclient.Authorization, path string) error {
	ret := _m.Called(ctx, auth, path)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, eosclient.Authorization, string) error); ok {
		r0 = rf(ctx, auth, path)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UnsetAttr provides a mock function with given fields: ctx, auth, attr, recursive, path
func (_m *EOSClient) UnsetAttr(ctx context.Context, auth eosclient.Authorization, attr *eosclient.Attribute, recursive bool, path string) error {
	ret := _m.Called(ctx, auth, attr, recursive, path)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, eosclient.Authorization, *eosclient.Attribute, bool, string) error); ok {
		r0 = rf(ctx, auth, attr, recursive, path)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateACL provides a mock function with given fields: ctx, auth, rootAuth, path, position, a
func (_m *EOSClient) UpdateACL(ctx context.Context, auth eosclient.Authorization, rootAuth eosclient.Authorization, path string, position uint, a *acl.Entry) error {
	ret := _m.Called(ctx, auth, rootAuth, path, position, a)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, eosclient.Authorization, eosclient.Authorization, string, uint, *acl.Entry) error); ok {
		r0 = rf(ctx, auth, rootAuth, path, position, a)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Write provides a mock function with given fields: ctx, auth, path, stream
func (_m *EOSClient) Write(ctx context.Context, auth eosclient.Authorization, path string, stream io.ReadCloser) error {
	ret := _m.Called(ctx, auth, path, stream)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, eosclient.Authorization, string, io.ReadCloser) error); ok {
		r0 = rf(ctx, auth, path, stream)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WriteFile provides a mock function with given fields: ctx, auth, path, source
func (_m *EOSClient) WriteFile(ctx context.Context, auth eosclient.Authorization, path string, source string) error {
	ret := _m.Called(ctx, auth, path, source)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, eosclient.Authorization, string, string) error); ok {
		r0 = rf(ctx, auth, path, source)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type mockConstructorTestingTNewEOSClient interface {
	mock.TestingT
	Cleanup(func())
}

// NewEOSClient creates a new instance of EOSClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewEOSClient(t mockConstructorTestingTNewEOSClient) *EOSClient {
	mock := &EOSClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
